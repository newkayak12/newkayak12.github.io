---
layout: post
categories: [ARCHITECTURE, DDD, HEXAGONAL]
---

# 조립

> - UseCase는 OutputPort에 대해서만 알고 구현은 런타임에 제공받는다.
> - Input은 UseCase를 제공 받고 구현은 런타임에 제공받는다.
- 위와 같은 상황이 올바른 상황이다. 실제로 이렇게 되려면 설정 컴포넌트가 있어야 한다.
- 맞다. 각 조각을 조립하는 것을 책임지고 각 조각들을 너무 많이 알아야 한다.
- 어찌 됐든 '전선을 얼마나 깔끔하게 정리할까?'와 같은 느낌이다. 없앨 수는 없다. 얼마나 아름답게 감추느냐가 관건이다.
- Spring은 ComponentScan으로 스캐닝하고 Spring이 관장해서 주입해준다.
- 물론 Spring 의존성이 증가하는 부분이 불편할 수는 있다.
- `@Bean`으로 등록하는 방법도 있으니 고민해볼만 하다.


# 경계
- 일정 규모 이상이 되면 보통 무너진다. 세워놨던 아키텍쳐가.
- 아키텍쳐 붕괴와 맞서기 위해서는 경계를 강제하는 방법이 있다. 
- 경계를 강제한다는 것은 의존성이 올바른 방향으로 향하게 하는 것을 의미한다.
- 또한 접근 제한자(package-private)으로 의도적으로 감추는 것도 굉장히 중요하다.
- package-private는 자바 패키지를 모듈 like로 만들어준다.
- 컴파일 후 의존성 방향 체크를 하는 방법도 있다. 예를 들어 `ArchUnit`이 있다.
- buildArtifact로 모듈, 아키텍쳐의 계층 간의 의존성을 강제할 수도 있다.
  - build 도구가 circular dependency를 참지 못한다는 점을 이용한다.
  - 또한 다른 모듈 고려 없이 특정 모듈만 빌드할 수도 있다. 이는 Test 계층을 마음대로 실행할 수 있다.
  - 마지막으로 buildScript에 선언되어 있기에 실수로라도 아키텍쳐 붕괴가 어려워진다.