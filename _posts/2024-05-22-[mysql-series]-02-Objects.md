---
layout: post
categories: [MYSQL]
---
from [Dictionary - Objects](https://github.com/newkayak12/Dictionary/blob/master/sql/02.Objects.md)


# 데이터베이스 객체

|  데이터베이스 객체   |                  설명                  |
|:------------:|:------------------------------------:|
|     테이블      |            데이터를 담고 있는 객체             |
|      뷰       | 하나 이상의 테이블을 연결해서 마치 테이블인 것처럼 사용하는 객체 |
|     인덱스      |      테이블에 있는 데이터를 빠르게 찾기 위한 객체       |
| 시노님(Synonym) |        데이터베이스 객체에 별칭을 부여한 객체         |
|     시퀀스      |        일련 번호 채번을 할 때 사용하는 객체         |
|      함수      |         특정 연상을 하고 값을 반환하는 객체         |
|     프로시저     |       함수와 비슷하지만 값을 반환하지는 않는 객체       |
|     패키지      |    용도에 맞게 함수나 프로시저를 하나로 묶어 놓은 객체     |


## 테이블 
1. 테이블명, 컬럼명의 최대 크기는 30byte
2. 테이블명, 컬럼명으로 예약어 사용 불가
3. 테이블명, 컬럼명으로 문자, 숫자, '_', '$', '#'을 사용할 수는 있지만 첫 글자는 문자로 고정
4. 한 테이블에 사용 가능한 컬럼은 최대 255

### 제약 조건
1. NOT NULL / NULLABLE
2. UNIQUE
3. PRIMARY KEY ( UNIQUE + NOT NULL )
4. FOREIGN KEY
5. CHECK ( 컬럼에 입력되는 데이터를 체크해서 특정 조건에 맞는 데이터만 입력 받고 나머지는 오류 )


## 뷰
하나 이상의 테이블이나 다른 뷰의 데이터를 볼 수 있게하는 데이터베이스 객체 SELECT 문으로 구성된다.
```sql
CREATE OR REPLACE VIEW [SCHEMA.]viewName AS
    SELECT ~ ; 

DROP VIEW [SCHEMA.]viewName;
```

## 인덱스
테이블에 있는 데이터를 빨리 찾기 위한 용도의 데이터베이스 객체

1. 인덱스 구성 컬럼 개수에 따른 분류 : 단일 인덱스와 결합 인덱스
2. 유일성 여부에 따른 분류 : UNIQUE/ NON-UNIQUE 인덱스
3. 인덱스 내부 구조에 따른 분류 : B-tree/ R-tree / Bitmap / 함수 기반 인덱스

```sql
CREATE [UNIQUE] INDEX [SCHEMA.]indexName
    ON [SCHEMA.]tableName( col1, col2 ... );
```

### 인덱스 생성 시 고려해야 할 사항
1. 일반적으로 테이블 전체 Row 수의 15% 이하의 데이터를 조회할 때 인덱스를 생성한다.
2. 테이블 건수가 적다면 (코드성 테이블) 굳이 인덱스를 만들 필요가 없다.
3. 데이터의 유일성 정도가 좋거나 범위가 넓은 값을 가진 컬럼을 인덱스로 만드는 것이 좋다.
4. NULL이 많이 포함된 컬럼은 인덱스 컬럼으로 만들기 적당하지 않다.
5. 결합 인덱스를 만들 떄는, 컬럼의 순서가 중요하다.  (자주 사용하는 컬럼을 순서상 앞에 두는 것이 좋다.)
6. 테이블에 만들 수 있는 인덱스 수의 제한은 없으나, 너무 많아도 성능 부하가 발생한다.

## 시노님(Synonym)

```sql
CREATE OR REPLACE [PUBLIC] SYNONYM [SCHEMA.]synonymName
FOR [SCHEMA.]Object;
```

PUBLIC을 생략하면 PRIVATE이 된다. FOR 이하에는 테이블, 뷰, 프로시저, 함수, 패키지, 시퀀스 등이 올 수 있다.


## 시퀀스(Sequence)
자동 순번을 반환하는 데이터베이스 객체.

## 파티션 
논리적으로 하나의 테이블이지만, 물리적으로는 분할한 만큼 파티션이 만들어져 입력되는 컬럼 값에 따라 분할된 파티션 별로 데이터가 저장된다.
보통 파티셔닝을 하는 목적은 대용량 테이블의 경우 데이터 조회 시 효율성과 성능을 높이기 위해서다.
