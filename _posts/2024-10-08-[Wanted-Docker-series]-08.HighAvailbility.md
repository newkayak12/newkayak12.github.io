---
layout: post
categories: [DOCKER, WANTED]
---

# High availability

## 왜?
1. 사용자가 늘어서 운영이 어려워 지고
2. 성능 유지는 필요하다.
    - 서버는 동시 요청 처리 한계가 명확하다.
    - 서버를 scale out하거나 scale up으로 사용자 경험을 유지할 수 있다.
3. 서버 한계 극복 위해서 고려할 요소
    - 가용성
    - 부하 분산
4. scaleout으로 서버 수 증가, -> 컨테이너 수 증가
5. 컨테이너의 효율적 관리 => 오케이스트레이션 기술 대두

## 한계에서부터 생각하기 -> 가용성
### 1. 가용성 향상
- 단일 서버는 단일 장애점이다. 
- 가용성은 지표다. 메트릭스로 측정해서 표현할 수 있다.
- 서버에서 가용성은 서버 또는 네트워크 시스템이 계획된 운영 시간 동안 얼마나 안정적으로 접근이 가능하고, 정상적으로 기능하는지에 대한 지표
- 기본적으로, 가용성은 시스템이 사용자의 요구를 충족시키며, 요청된 서비스를 제공할 수 있는 능력을 의미한다.

### 2. 가용성의 중요 요소
- 연속성과 신뢰성: 예상치 못한 중단 없이 지속적으로 작동하고, 예정된 유지 관리 외에 다운타임이 회소화 되어야 함
- 복구력: 장애 후 얼마나 빠르게 정상으로 돌아오는지도 중요
- 확장성: 사용자 수나 데이터량 증가 등, 시스템에 대한 요구가 변화할 때 이를 수용하고 성능을 유지할 수 있는 능력

> 가용성을 높이는 방법
> 1. 하드웨어 중복
> 2. 로드밸런싱
> 3. failover 시스템
> 4. 정기적인 백업 및 복구 테스트 (ChaosMonkey같은 툴로)
> 5. 분산 아키텍쳐

### 3. 주요 가용성 지표
- 가동 시간(Uptime) : 중단 없이 가동된 시간의 비율을 의미 (99.9% 가동시간이 보장되면 연간 8.76시간의 다운타임을 가질 수 있다.)
- 장애 복구 시간(Recovery Time Objective, RTO) : 얼마나 빨리 복구할 수 있는지를 의미한다. (장애 후 서비스가 다시 정상적으로 운영되는데 걸리는 시간)
- 데이터 손실 허용 시간(Recovery Point Objective, RPO) : 시스템 장애 발생시 데이터 손실을 허용할 수 있는 최대 시간을 의미 ( 복구 시점, 장애 시점 사이의 손실된 데이터를 기준으로 한다.)
- 무중단 운영(Failover): 장애가 발생하면 자동으로 대체 서버나 복제 서버로 전환되어 서비스 중단 없이 운영이 계속되는 것을 의미

## 고갸용성
- 최대한 오랫동안 중단 없이 운영되도록 보장되는 아키텍쳐
- 복제 서버, 백업 서버, 이중화 시스템, 로드 밸런싱 등의 기술로 서비스 중단 없이 처리

### 1. 복제 서버 (Replication Servers)
- 역할: 복제 서버를 통해서 실시간 데이터 복제를 실행 -> 메인에서 처리된 모든 데이터를 동시에 다른 서버에 복제하여, 장애가 발생해도 복제 서버에서 동일한 데이터를 가지고 서비스를 지속

#### Master-Slave
- 작동 방식
  - Master에서 모든 데이터 변경 작업이 이뤄지고 Slave에서 읽기 전용 작업만 수행
  - 복제는 단방향, Slave는 주 서버의 데이터를 따라간다.
- 차이점
  - Slave는 읽기 전용, 쓰기는 주로 Master에서
  - 비동기 복제가 일반적이지만, 동기 복제로도 설정할 수 있다.

#### Master-Master
- 작동 방식
  - 여러 서버가 동시에 읽기, 쓰기를 수행
  - 서버 간 서로의 데이터를 실시간으로 동기화한다.
  - 데이터 충돌 방지를 위해서 충돌 관리 메커니즘이 필요
- 차이점
  - 모든 서버가 동등한 역할을 하며, 읽기와 쓰기를 모두 처리할 수 있다.
  - 데이터의 동기화 복잡성이 커지고, 데이터 충돌이 발생할 수 있다.
  - 보통 동기 또는 반동기 복제 형식으로 동작하며 모든 서버 간 일관성 유지가 어렵다.

#### 실시간 동기활르 통한 복제 서버 구현

1. 동기식 복제(Synchronous)
- 동기식 복제는 Primary에서 오는 모든 데이터를 Seconary에 동시에 반영하는 방식이다
- 주 서버는 복제 서버가 변경 사항을 완전히 저장할 때까지 작업을 완료하지 않는다.
- 일관성 보장 측면에서는 좋지만 지역 시간이 발생할 수 있다

> 작동 방식
> - 트랜잭션이 발생하면 변경하고 복제 서버로 전송
> - 복제서버가 수신하고 적용되었다고 주 서버로 알림
> - 주 서버는 수신 이후 트랜잭션을 완료

- 장점
  - 높은 데이터 일관성이 보장된다.
  - 주, 복제 서버 간 높은 싱크로율이 유지된다.
- 단점
  - 지연 시간이 발생할 수 있다.

2. 비동기식 복제(Asynchronous)
- 주 서버가 데이터 변경을 수행한 후, 즉시 다음 작업을 진행하고 복제 서버는 별도의 시간에 변경 사항을 적용한다.
- 주 서버는 상태를 기다리지 않기에 처리 속도는 빠르지만 일시적으로 데이터 불일치가 발생할 수 있다.

> 작동 방식
> - 주 서버에서 트랜잭션이 발생하면 즉시 변경 사항을 기록하고 트랜잭션을 완료
> - 변경된 데이터를 복제 서버로 전송하면 주 서버는 복제 서버 응답을 기다리징 낳음
> - 복제서버는 전송된 데이터를 나중에 적용하여 동기화를 완료

- 장점
  - 성능이 뛰어나도 빠른 처리 속도를 유지
  - 복제 서버가 원거리에 있을 때도 큰 성능 저하가 없음
- 단점
  - 일시적으로 데이터 불일치가 발생할 수 있다.

3. 스트리밍 복제
- 주 서버에서 로그 파일을 실시간으로 스트리밍하여 복제 서버에 데이터를 전송하는 방식
- 비동기식과 비슷하지만 데이터 전송이 보다 실시간에 가까움

> 작동 방식
> - 주 서버는 데이터 변경 시 변경된 데이터의 로그 파일을 생성
>   - 트랜잭션 데이터를 WAL(Write-Ahead Logging)파일로 기록
>   - WAL은 데이터가 디스크에 쓰이기 전에 로그 파일에 먼저 기록되는 방식
>   - 데이터 일관성을 유지하는 데 중요한 역할을 한다.
> - 로그 파일은 스트리밍 방식으로 실시간 복제(Replica) 서버로 전송
>   - WAL Sender는 실시간으로 WAL 파일을 서버로 스트리밍
> - 복제 서버는 이 로그를 즉시 적용하거나 일정 시간 후에 적용하여 데이터 일관성을 맞춤
>   - Replica 서버는 WAL Receiver를 통해서 WAL 파일을 수신하고 재생하여 Primary와 동기화
> - Replica 서버는 읽기 전용 상태로 클라이언트 요청에 대응
> - 필요 시 FailOver를 통해서 Primary역할을 할 수도 있다.

- 장점
  - 지연이 적고, 데이터가 실시간에 가깝게 동기화
  - 동기식, 비동기식의 장점을 결합한 방식
  - 데이터 일관성 유지와 성능을 적절히 균형 있게 관리할 수 있다.
- 단점
  - 완벽한 동기식 복제처럼 즉각적인 데이터 일관성을 보장하지는 않음



### 2. 백업 서버
- 비상시에만 사용되는 서버
- 메인서버, 복제 서버에 심각한 장애가 발생할 경우 데이터 복구 및 서비스 복원을 위해서 사용
- 보통 원격지에 위치하며, 데이터 복구 및 재해 복구 전략( DisasterRecover, DR )의 핵심점 역할을 담당

### 3. 이중화
- 이중화 메커니즘을 통해 장애 발생 시 자동으로 다른 서버로 전환하는 기능을 제공
- 한 서버가 다운되면 다른 서버가 즉시 이어 받아 중단 없는 서비스를 제공
- 이중화 시스템은 자동 전환을 통해 서비스 중단을 최소화하고, 연속적인 서비스 가용성을 유지

### 4-1. 로드 밸런싱
- 고가용성 아키텍쳐는 로드 밸런서를 통해 여러 서버 간의 트래픽을 분산하여, 서버 과부하를 방지하고 최적 성능을 유지
- 많은 사용자가 동시에 접속해도 안정성을 유지할 수 있다.
- 자동으로 서버 상태를 감시하고, 트래픽을 가장 적절한 서버로 분배해서 시스템의 가용성을 보장

### 4-2. 부하 분산
- 서버를 추가하면 네트워크 트래픽과 데이터 처리 부하를 여러 서버에 분산시켜 각 서버의 부하를 줄일 수 있다.
- 각 서버의 안정성을 제고하고, 전체 시스템의 효율성이 증가

> 부하
> - 부하는 일반적으로 서버, 네트워크가 처리해야하는 데이터의 양, 요청 수 또는 동시 사용자 수등으로 인해 발생하는 작업량이나 스트레스르 의미
> - 부하의 주요 유형
>   - CPU
>   - Memory
>   - DISK I/O
>   - Network
> 
> - 부하가 서버에 미치는 영향
>   - 응답 시간 증가
>   - 시스템 다운
>   - 리소스 경합
> 
> - 관리 방법
>   - 부하 분산(LoadBalancing)
>   - Scaling
>   - Caching

### 5. 재난 복구
- 여러 지역에 서버를 분산시켜 두면 자연재해나 기타 여러 상황에서 서비스의 연속성을 보장할 수 있다.

### 6. 데이터 처리 능력 증가
- 사용자 증가에 따른 처리 요구 증가
- DB, Server, ApplicationServer를 증설하여 처리 능력을 높일 수 있다.

### 7. 확장성
- 시스템 확장성이 높아야 유연하게 대응하 룻 있다.

## 결과적으로
- Scaling으로 귀결된다. 적당히 늘리고 투자해야 한다.


1. 유연성과 확장성: 서버나 리소스의 필요에 따라 추가하거 제거할 수 있다.
2. 비용 효율성: 고성능 서버 하나보다 일반 성능 여러 개가 비용이 저럼
3. 고갸용성: 한 노드가 실패하더라도 중단 없이 다른 노드가 작업을 수행
4. 부하 분산: 트래픽이나 작업 부하를 여러 서버에 분산

# Kubernetes
- 서버 수가 늘어나고 도커 컨테이너 수도 증가
- 컨테이너들을 효과적으로 관리하고 조정하는데 어려움이 있음
- 도커 오케스트레이션 기술의 대두

> 가용성
> - Pod의 가용성을 보장하기 위해서 self-healing을 제공
> - Pod하나가 장애로 종료되면 k8s는 즉시 새 pod를 생성
> - autoScaling, self-healing을 통해서 장애 발생시 자동 복구

- Pod의 가용성을 보장하기 위해서 selfHealing, autoScaling을 사용한다.
- 이를 통해 자동으로 복구하고 Pod의 개수를 동적으로 조절한다.
- 무중단 서비스를 제공한다.

> Pod
> - 가장 작은 단위의 컴퓨팅 리소스이다.
> - 애플리케이션의 인스턴스로 볼 수 있다.
> - K8s는 Pod를 통해서 애플리케이션의 실행 환경을 추상화, 컨테이너 간의 네트워크와 스토리지 관리
> - Pod는 일시적이며, 언제든 중단될 수 있으므로 이 경우 새로운 Pod를 아예 새로 띄운다.

- Self-Healing
  - 자체 복구는 K8s의 중요 기능 중 하나다.
  - 장애로 인한 종료, 비정상적 상태에 복구하는 메커니즘
  - 클러스터 상태를 지속적으로 모니터링하거나, Pod를 탐지하고 이를 교체
- AutoScaling
  - 트래픽, 부하 변동에 따라서 자동으로 Pod 개수를 늘리거나 줄임
  - HPA(Horizontal Pod Autoscaler)를 이용해서 CPU나 메모리에 따라 Pod 수를 조절
- 가용성 보장
  - 가용성은 Pod의 지속적인 샐행을 보장하는 것과 관련이 있음
  - Pod가 종료되거나 장애가 발생시 복구 메커니즘으로 항상 실행 가능한 상태를 유지
  - ReplicaSet, Deployment는 애플리케이션의 desiredState(원하는 상태)를 정의하고 이를 맞추려고 조정함

> 테스트와 측정
> 1. 모니터링 도구 : Datadog, NewRelic, Prometheus
> 2. Uptime모니터링 서비스: UptimeRobot, Pingdom
> 3. 부하 테스트: JMeter, Gatling, LoadRunner
> 4. 장애 조치 테스트 : 재난 복구 시나리오
> 5. 카오스 엔지니어링: Netflix의 ChaosMonkey
> 6. 번치마킹 : 성능 벤치마킹 또느 이전과 비교가 용이


> 성능 지표
> 1. Throughput: 시간 내 일머나 만흥 작업을 처리할 수 있느닞
> 2. responseTime: 요청 처리에 걸리는 시간을 의미
> 3. Latency : 지연시간을 의미하며, 요쳥을 처리하기 위해서 걸리는 시간(효율성)
> 4. Concurrency: 동시에 처리할 수 있는 요청의 수 
> 5. Scalability: 추가적인 하드웨어나 리소스를 투입할 때 얼마나 성능향상이 있는지를 의미
> 6. CPU, Memory 사용률
> 7. 에러율 : 시스템이 처리 중 발생한느 오류 비율