---
layout: post
categories: [JAVA, ANTI-PATTERN]
---

# Thread starvation

- 특정 쓰레드가 공유 리소스를 장시간 보유하는 다른 쓰레드로 인해 공유 리소스에 접근하지 못하고 성능이 저하되고 교착상태까지 발생할 수 있다.

## 원인
1. Blocking
2. Deadlock
3. 동기화 불량: 부적절한 동기화는 동시성 제어 메커니즘을 사용해서 동기화되지 않으면 동시에 액세스해서 충돌이 일어날 수 있다.
4. 불충분한 쓰레드 풀 구성: 쓰레드 풀을 너무 작거나 큐를 적게 잡으면 가용 쓰레드를 기다리면서 쓰레드 고갈이 생길 수 있다.

## 감지
1. 높은 CPU 사용량 : 쓰레드가 리소스, 컨텍스트 스위칭을 위해서 지속적으로 경쟁하기에 사용량이 비정상적으로 높아진다.
2. 유난히 긴 응답시간 : 특히 Blocking 작업이 느려지면 쓰레드 고갈로 이어진다.
3. 낮은 처리량 : 가용 쓰레드가 부족해서 처리량도 줄어든다.
4. 교착상태 : 혹여 deadlock이 자주 발생하면 쓰레드 고갈이 문제일 수도 있다.

## 해결
1. 비동기로 구성하기 : blocking 작업을 offload하고 다른 작업을 위한 쓰레드 확보할 수 있는 비동기 작업으로 구성하면 가용 리소스의 활용을 최고로 올릴 수 있다.
2. 잠금 컨텐션 감소 : 동기화 메커니즘을 최적화하여 잠금 경합을 줄이고 쓰레드 고갈 가능성을 줄인다.
3. 쓰레드 풀 조정 : 적정한 쓰레드 풀, 작업 큐로 원활한 작업 환경을 구성한다.
4. 성능 모니터링, 분석
5. 타임아웃 메커니즘 : 일정 시간이 지나면 실패로 처리해서 순환을 문제가 생겼을 경우 failover 할 수 있도록 둘 수도 있다.
6. 리소스 액세스 최적화 : 공유 리소스 액세스 방식을 최적화하여 경합을 줄이는 방식으로 최적화할 수도 있다.