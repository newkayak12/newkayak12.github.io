---
layout: post
categories: [OTHERS]
---
from [Dictionary - OS](https://github.com/newkayak12/Dictionary/blob/master/cs/OS.md)



# OS
운영체제의 역할

1. CPU 스케쥴링 프로세스 관리 : CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리한다.
2. 메모리 관리 : 한정된 메모리를 어떤 프로세스에 얼만큼 할당할지 관리한다.
3. 디스크 파일 관리 : 디스크 파일을 어떤 방법으로 보관할지 관리한다.
4. I/O 디바이스 관리 : I/O 디바이스들과 컴퓨터 간의 데이터를 주고 받는 것을 관리한다. 

 
![](/assets/img/os.png)

시스템 호출(systemCall)이란 운영체제가 커널에 접근한기 위한 인터페이스이며, 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 쓴다.


# 컴퓨터의 요소
컴퓨터는 CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등으로 이뤄져 있다. 

## CPU
1. CU(ControlUnit) : 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정한다.
2. 레지스터 : 매우 빠른 임시기억 장치 
3. 산술논리연산장치 : 덧셈, 뺄셈 같은 두 숫자의 산술연산, 배타적 논리합, 곱 등같은 논리 연산을 계산하는 디지털 회로 

## DMA
I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치. CPU에만  너무 많은 인터럽트 요청이 들어오기 때문에 CPU 부하를 막아주며, CPU의 일을 부담하는 역할을 한다.

## 메모리
메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어 있다. 
1. 레지스터 : CPU 안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적음
2. 캐시 : L1, L2 캐시를 지칭, 휘발성, 속도 빠름, 기억 용량이 적음, L3도 있다.
3. 주기억장치 : RAM을 가리킨다. 휘발성, 속도 보통, 기억 용량이 보통
4. 보조기억장치 : HDD, SSD를 일컬으며 비휘발성, 속도 낮음, 기억 용량 많음

## 캐시 
캐시는 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목을 줄이기 위해서 사용하는 메모리를 말한다. 이를 통해 
데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있다.

### 지역성의 원리 
자주 사용하는 데이터를 기반으로 설정해야 한다. 자주 사용하는 데이터에 대한 근거가 무엇일까? 시간 지역성(temporal locality), 공간 지역성(spatiaal locality)가 있다.

1. 시간 지역성
최근 사용한 데이터에 다시 접근하려는 특성을 말한다.
 
2. 공간 지역성
최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성을 말한다. 

### 캐시 미스, 히트
원하는 데이터를 찾는 것을 캐시 히트 반대를 캐시 미스라고 한다. 

### 메모리 관리
가상 메모리는 메모리 관리 기법의 하나로 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 의미한다.


### 스와핑
가상 메모리에 존재하지만 실제 메모리인 RAM에는 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생한다. 이때 메모리에서 당장 사용하지 않는 영역을 HDD로 옮기고 
HDD의 일부분을 마치 메모리처럼 불러와 쓰는 것을 스와핑이라고 한다. 

### 페이지 폴트
프로세스의 주소 공간에는 존재하지만 RAM에는 없는 데이터에 접근했을 경우 발생한다. 
1. 명령어가 유효한 가상 주소에 접근했으나 해당 페이지가 없다면 트랩이 발생해서 운영체제에 알리게 된다.
2. OS는 실제 디스크로부터 사용하지 않은 프레임을 찾는다.
3. 해당 프레임을 실제 메모리에 가져와 페이지 교체 알고리즘을 기반으로 특정 페이지와 교체(스와핑)
4. 페이지 테이블을 갱신시킨 후 해당 명령을 다시 시

### 쓰레싱
Thrashing은 메모리의 페이지 폴트율이 높은 것을 의미하며, 컴퓨터의 성능 저하를 초래한다. 

### 메모리 할당
시작 메모리 위치, 메모리 할당 크기를 기반으로 할당하는데, 연속 할당과 불연속 할당으로 나뉜다. 

1. 연속 할당 : 메모리에 '연속적으로' 공간을 할당하는 것을 의미
- 고정 분할 방식(fixed partition allocation) : 메모리를 미리 나누어 관리하는 방식이며, 메모리가 미리 나뉘어 있기 때문에 융통성이 없다. 또한 내부 단편화가 발생한다. 
- 가변 불할 방식(variable partition allocation) : 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용한다. 내부 단편화는 없지만 외부 단편화가 있을 수 있다. (최초 적합, 최적 적합, 최악 적합이 있다.)

|    이름     |               설명               |
|:---------:|:------------------------------:|
| First Fit |  위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당  |
| Best Fit  | 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당 |
| Worst Fit |  프로세스의 크기와 가장 많이 차이가 나는 홀에 할당  |

>
> 내부 단편화(Internal Fragmentation) : 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상
> 외부 단편화(External Fragmentation) : 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 경우 
> 홀 (hole) : 할당할 수 있는 비어 있는 메모리 공간
> 

2. 불연속 할당
현대 OS가 쓰는 방법, 메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당하는 것, 페이징 말고 세그맨테이션, 페이지드 세그멘테이션이 있다.
- Paging : 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당한다. 홀의 크긱가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해진다.
- Segmentation : 페이지가 아닌 의미 단위인 세그먼트로 나누는 방식이다. 프로세스를 이루는 메모리는 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 이뤄지는데, 코드 내의 작은 함수를 세그먼트로 놓고 나눌 수도 있다. 이는 공유와 보안 측면에서 장점을 가지지만 홀 크기가 균일하지 않는 단점이 있다.
- Paged Segmentation : 세그먼트로 나누는데, 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누는 것을 의미한다.

>
> 페이지 교체 알고리즘
> offline : 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이다. 
> FIFO(First In First Out) : 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법을 의미한다. 
> LRU(Least Recently Used) : 참조가 가장 오래된 페이지를 바꾼다. 
> NUR(Not Used Recently) : LRU에서 발, clock 알고리즘, 시계 방향으로 돌며 참조하면 1, 아니면 0. 0을 찾은 순간 해당 프로세스를 교체하고 해당 부분을 1로 바꾸는 알고리즘
> LFU(Least Frequently Used) : 가장 참조 횟수가 적은 페이지를 교체한다. 
> 


## 프로세스 상태
![](/assets/img/process.jpg)

New : 프로세스 생성 상태, fork(), exec() 함수로 생성
- fork() : 부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수 (주소 공간만 복사)
- exec() : 새롭게 프로세스를 생성하는 함수 

Ready : 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기, CPU 소유권이 넘어오기를 기다림
Ready Suspend : 메모리 부족으로 일시 중단된 상태

Blocked : 어떤 이벤크가 발생한 이후 기다리며 프로세스가 차단된 상태. I/O 디바이스에 의한 인터럽트로 이런 현상이 많이 발생하기도 한다. 
Blocked Suspend : 대기 중단과 유사. 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태

Terminated : 메모리와 CPU 소유권을 모두 놓고 가는 상태부모가 자식 프로세스를 강제로 비자발적 종료로 종료되는 것도 있다. 자식 프로세스가 할당된 자원의 한계치를 넘어서거나 부모 프로세스가 종료되거나 사용자가 process kill로 프로세스를 종료할 때 발

## 컨텍스트 스위칭
PCB를 기반으로 프로세스 상태를 저장하고 로드시키는 과정, 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다.

>
> PCB ( Process Control Block ) : 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터를 말한다. 프로세스 제어 블록이라고도 한다.
> 

## 쓰레드, 멀티 쓰레딩
쓰레드 : 프로셋의 실행 가능한 가장 작은 단위
멀티쓰레드 : 프로세스 내 여러 개의 쓰레드, 멀티 쓰레드로 처리하는 기법 쓰레드끼리 자원을 공유하기 때문에 효율성이 높음

## 공유 자원
shared resource는  시스템 안에서 각 프로세스, 쓰레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일 등의 자원이나 변수를 의미한다. 이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을
경쟁 상태(race condition)이라고 한다.  동시 접근 시 타이밍, 순서 등이 결과에 영향을 준다. 

## 임계 영역 
둘 이상의 프로세스, 쓰레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역을 말한다. 임계영역을 해결하는 방법은 뮤텍스, 세마포어, 모니터 세 가지가 있다. 
모두 상호 배제, 한정 대기, 융통성이라는 조건을 만족한다. 

> 
>  상호 배제(mutual exclusion)
> 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다. 
> 
> 한정 대기(bounded waiting)
> 특정 프로세스가 영원히 임계 영역에 들어가지 못하게 하면 안 된다.
> 
> 융통성(progress)
> 만약 어떠한 프로세스도 임계 영역을 사용하지 않으면 임계 영역 외부의 어떠한 프로세스도 들어갈 수 있으며, 이 때 프로세스끼리 서로 방해하지 않는다. 
> 

[세마포어, 뮤텍스, 모니터](SemaphoreAndMutex.md)


## 교착 상태(Deadlock)의 원인
- 상호 배제 : 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가
- 점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태
- 비선점 : 다른 프로세스의 자원을 강제적으로 가져올 수 없다. 
- 환형 대기 : 프로세스A는 프로세스B의 자원을 요구하고, 프로세스B는 A의 자원을 요고하는 상황

## 해결 방법
1. 자원 할당 시 조건이 설림하지 않도록 설계
2. 교착 상태 가능성이 없을 때만 자원을 할당하며, 프로세스 당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 `은행원 알고리즘`을 쓴다.
3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지운다.
4. 거의 일어나지 않지만 처리하는데 비용이 크다. 그래서 사용자에게 판단을 위임한다. 