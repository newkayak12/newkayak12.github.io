---
layout: post

categories: [OOP]
---

## 합성과 유연한 설계

- 합성에서 두 객체 사이의 의존성은 런타임에 해결된다.
- 상속은 `is-a`, 합성은 `has-a`
- 합성은 구현에 의존하지 않는다. 합성은 내부에 포함되는 객체 구현이 아닌 퍼블릭 인터페이스에 의존한다.
- 상속은 정적인 관계인 데 비해 합성 관계는 객체 사이의 동적인 관계이다.
- 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다.
- 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있는 것이다.
> - 상속은 다른 클래스를 이용해서 한 클래스의 구현을 정의하는 것이다.
> - 서브클래싱에 의한 재사용을 화이트박스 재사용이라고 부른다.
> - 객체 합성은 상속의 대안이다. 객체를 합성하려면 합성할 객체들의 인터페이스를 명확하게 정의해야 한다.
> - 이를 블랙박스 재사용이라고 한다. 객체 내부 공개 없이 인터페이스를 통해서만 재사용하기 때문이다.

### 상속을 합성으로
**상속의 문제점**
- 불필요한 인터페이스 상속 문제
- 메소드 오버라이딩 오작용 문제
- 부모, 자식 동시 수정 문제
- 상속 남용으로 하나의 기능 추가를 위해서 필요 이상으로 많은 수의 클래스를 추가하는 경우를 **클래스 폭발**이라고 한다.
- 상속은 컴파일 타임에 결정되고 고정되기에 코드를 실행하는 도중에는 변경할 수 없다.

**합성으로 변경**
- 합성을 사용하면 구현 시점에 정책들의 관계를 고정시킬 필요가 없으며 실행 시점에 정책들의 관계를 유연하게 변경할 수 있게 된다.
- 인터페이스를 구현하고, 인터페이스를 의존하도록 둔다.
- 추가적으로 외부에서 의존성을 주입 받을 수 있도록 구성한다.