---
layout: post

categories: [SPRING, BATCH]
---

### 2. Step
> -  작업 내 독립적 단위
> -  스텝을 연결해서 순차적 처리 흐름을 형성할 수도 있다.
1. 세분화 : 성능 및 최적화를 위해서 독립적으로 조장할 수 있어서 효율적인 디버깅 및 테스트가 가능하다.
2. 작업 및 청크 지향 처리 : Tasklet으로 정의되거나 Chunk로 정의될 수 있다.
3. 리스너 : 사전 및 사후 처리 작업을 수행하기 위한 생명 주기 이벤트에 후킹하기 위해서 리스너를 사용할 수 있다.

#### 2.1 생명 주기
1. 작업 시작 : 타이머 이벤트나 수동 요청과 같은 트리거에 따라 초기화되고 시작
2. 단계 실행 : 작업에 정의된 단계가 구성에 따라 순차적으로 또는 병렬로 실행
3. 완료 : 모든 단계가 성공적으로 완료되면 작업은 완료로 표시
4. 작업 레포지토리 상호 작용 : 생애 주기 동안 작업 실행 세부 정보는 작업 레포지토리에 저장

#### 2.2. 작업 상태
1. 시작 중
2. 시작 됨
3. 완료
4. 실패

#### 2.3. 단계 실행 생명 주기
1. 초기화 : 단계 시작 되기 전에 준비되고 관련 매개변수 설정
2. 실행 : 실제 처리가 진행, 작업, 청크지향처리로 이뤄짐
3. 완료: 성공, 실패를 보고
4. 커뮤니케이션 : 다음 단계로 진행하거나 종료

#### 2.4. 단계 상태
1. 시작 중
2. 시작 됨
3. 완료
4. 실패

#### 2.5 작업 매개변수
> `JobParameter jobParameter = new JobParamter()`로 선언

#### 2.6. 분할/ 확장
- 성능 향상을 위해서 작업을 분할할 수 있다.
- 분할은 단일 단계를 여러 개의 작은 단위로 나눠서 병렬로 실행할 수 있게 한다.

```java
@Bean
public Partitioner partitioner() {
    return new CustomPartiioner();
}
```

#### 2.7 처리 유형
> `StepBuilderFactory`로 구현
1. Tasklet Step:
    - 파일 삭제 또는 단일 트랜잭션 수행과 같은 단일 작업을 위해서 설계된 간단한 단계
    - Tasklet interface 구현으로 정의할 수 있다.
2. Chunk-Oriented Step:
    - 데이터를 청크로 읽고 처리한며 쓰는데 사용
    - 데이터는 지정된 크기의 청크로 읽힌 다음 처리되고 작성된다.
    - 많은 양의 데이터를 처리하는 데 효율적이며 메모리 사용을 최소화
3. Partition Step
    - 여러 쓰레드 또는 파티션에 걸쳐 작업 부하를 나눠서 데이터를 병렬 처리
    - 각 파티션은 데이터의 하위 집합을 동시에 처리하여 성능을 향상
4. Flow Step
    - 여러 정의된 StepFlow 내에서 오케스트레이션 할 수 있게 한다.
    - 조건부 실행이 필요한 복잡한 작업 구조에 적
